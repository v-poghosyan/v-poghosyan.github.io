<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vahram Poghosyan">
<meta name="dcterms.date" content="2023-01-13">

<title>A Beginner’s Introduction to Concepts in Functional Programming – v-poghosyan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-KLCX05QFPN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-KLCX05QFPN', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">v-poghosyan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Info</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">A Beginner’s Introduction to Concepts in Functional Programming</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Functional Programming</div>
                <div class="quarto-category">Recursion</div>
                <div class="quarto-category">Scala</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vahram Poghosyan </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 13, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mathematical-functions" id="toc-mathematical-functions" class="nav-link active" data-scroll-target="#mathematical-functions">Mathematical functions</a></li>
  <li><a href="#pure-functions-and-side-effects" id="toc-pure-functions-and-side-effects" class="nav-link" data-scroll-target="#pure-functions-and-side-effects">Pure functions and side effects</a>
  <ul>
  <li><a href="#nice-consequences-of-working-with-pure-functions" id="toc-nice-consequences-of-working-with-pure-functions" class="nav-link" data-scroll-target="#nice-consequences-of-working-with-pure-functions">“Nice” consequences of working with pure functions</a></li>
  </ul></li>
  <li><a href="#declarative-vs-imperative-styles" id="toc-declarative-vs-imperative-styles" class="nav-link" data-scroll-target="#declarative-vs-imperative-styles">Declarative vs imperative styles</a>
  <ul>
  <li><a href="#side-effects" id="toc-side-effects" class="nav-link" data-scroll-target="#side-effects">Side-effects</a></li>
  <li><a href="#instructions-statements-vs-expressions" id="toc-instructions-statements-vs-expressions" class="nav-link" data-scroll-target="#instructions-statements-vs-expressions">Instructions (statements) vs expressions</a></li>
  <li><a href="#control-flow-conditional-statements-and-loops" id="toc-control-flow-conditional-statements-and-loops" class="nav-link" data-scroll-target="#control-flow-conditional-statements-and-loops">Control flow: conditional statements and loops</a></li>
  <li><a href="#function-composition-vs-iteration-and-higher-order-functions-hofs" id="toc-function-composition-vs-iteration-and-higher-order-functions-hofs" class="nav-link" data-scroll-target="#function-composition-vs-iteration-and-higher-order-functions-hofs">Function composition vs iteration and higher-order functions (HOFs)</a>
  <ul>
  <li><a href="#higher-order-functions" id="toc-higher-order-functions" class="nav-link" data-scroll-target="#higher-order-functions">Higher-order functions</a></li>
  </ul></li>
  <li><a href="#currying" id="toc-currying" class="nav-link" data-scroll-target="#currying">Currying</a></li>
  <li><a href="#monads" id="toc-monads" class="nav-link" data-scroll-target="#monads">Monads</a></li>
  </ul></li>
  <li><a href="#benefits-of-functional-programming" id="toc-benefits-of-functional-programming" class="nav-link" data-scroll-target="#benefits-of-functional-programming">Benefits of functional programming</a>
  <ul>
  <li><a href="#parallelization" id="toc-parallelization" class="nav-link" data-scroll-target="#parallelization">Parallelization</a></li>
  </ul></li>
  <li><a href="#functional-programming-hazards" id="toc-functional-programming-hazards" class="nav-link" data-scroll-target="#functional-programming-hazards">Functional programming hazards</a>
  <ul>
  <li><a href="#tail-recursion-avoiding-stack-overflow" id="toc-tail-recursion-avoiding-stack-overflow" class="nav-link" data-scroll-target="#tail-recursion-avoiding-stack-overflow">Tail recursion: avoiding stack overflow</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<p>Functional programming draws inspiration from the mathematical definition of a function which is a well-defined operation on sets.</p>
<section id="mathematical-functions" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-functions">Mathematical functions</h2>
<p>Take <span class="math inline">\(f: X \rightarrow Y\)</span>, which is a <strong>function</strong> that maps elements of the set <span class="math inline">\(X\)</span> to those of the set <span class="math inline">\(Y\)</span>, such that for each <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span> (also denoted “<span class="math inline">\(x \in X\)</span>”), there’s <em>one and only one</em> <span class="math inline">\(y \in Y\)</span> that satisfies the equation <span class="math inline">\(f(x) = y\)</span>. In plain language we say that a mathematical function maps any given input to its own unique output (that depends only on the input). That’s not to say that <span class="math inline">\(f\)</span> can’t map the two different inputs, <span class="math inline">\(x_i\)</span>, and <span class="math inline">\(x_j\)</span>, to the same output <span class="math inline">\(y\)</span>, but it <em>cannot</em> map the same input <span class="math inline">\(x_i\)</span> to more than one output.</p>
<p>Notice that the output in <span class="math inline">\(Y\)</span> depends <em>only</em> on the input from set <span class="math inline">\(X\)</span>, and that the function <span class="math inline">\(f\)</span> <em>only</em> operates on set <span class="math inline">\(X\)</span> and nothing external to it. In other words there is no <em>hidden state</em> (some value outside of <span class="math inline">\(X\)</span>) that affects <span class="math inline">\(f\)</span>-s output, so <span class="math inline">\(f\)</span> always produces predictable output. What’s more <span class="math inline">\(f\)</span> doesn’t really alter any element in <span class="math inline">\(X\)</span> itself (or, for that matter, in <span class="math inline">\(Y\)</span>). The expression <span class="math inline">\(f(x)\)</span> is simply understood as the function <span class="math inline">\(f\)</span> applied to an element <span class="math inline">\(x \in X\)</span> which maps it to an element in set <span class="math inline">\(Y\)</span>. However, it’s not like <em>the</em> specific element in the set <span class="math inline">\(X\)</span> is somehow retrieved (as it is sometimes, by reference, in programming) and overwritten in any way.</p>
<p>The idea behind functional programming is to bring code close to this mathematical elegance, allowing us to better reason about the systems we write.</p>
</section>
<section id="pure-functions-and-side-effects" class="level2">
<h2 class="anchored" data-anchor-id="pure-functions-and-side-effects">Pure functions and side effects</h2>
<p>We can define some rules for the functions we write in our code to match the mathematical properties of functions, bridging the concrete world of mathematics with the practical world of software engineering.</p>
<p>A <strong>pure function</strong>, in the FP sense, is a function which depends only on its input (and not on any other value stored elsewhere in external computer memory or other external source). A pure function affects nothing outside itself. Additionally, pure functions <em>must</em> output a value and that value must be unique for a given input.</p>
<p>To recap:</p>
<ol type="1">
<li>A pure function must return a single output for a given input</li>
<li>Its output should only depend on its input</li>
<li>A pure function shouldn’t change any internal or external state</li>
</ol>
<p>Given that a functional program is just a composition of pure functions, and that state changes are often what affects the real-world outcome of our function calls (more on these <strong>side-effects</strong> later), the last property effectively means that pure functions don’t mutate state at all. This is also the reason state mutation is often frowned upon, in general, in functional programming. This presents unique challenges, as you might expect, given that so many operations in the traditional paradigm of programming used within countless real-world codebases <em>do</em> mutate state (in fact, in some cases, they have to – for anything useful to ever happen). But some state mutation is definitely avoidable.Take, for instance, a <code>for</code> loop which increments its index on every iteration. We will see how functional programming languages attempt to bypass for loops, or iteration in general, in favor of function composition (syntactic sugars, in your choice of language, will become indispensable here!).</p>
<section id="nice-consequences-of-working-with-pure-functions" class="level3">
<h3 class="anchored" data-anchor-id="nice-consequences-of-working-with-pure-functions">“Nice” consequences of working with pure functions</h3>
<p>Working with pure functions conveys some great benefits. For instance, properties (1) and (2) make pure functions interchangeable with their output (just as, say, <span class="math inline">\(f(2)\)</span> given <span class="math inline">\(f(x)=x^2\)</span> can reliably be substituted for the number <span class="math inline">\(4\)</span> in math). This allows us to pass in pure functions as arguments into other pure functions (as well as return them as output) with entirely predictable results. If a function, by contrast, printed something to the console, along with evaluating the square, we would consider that an <strong>effectful</strong> function (and therefore it would be considered impure). Such a function <em>cannot</em> be reliably substituted by its output because it also affects an external state, producing an effect that the output alone does not capture. This benefit, to reliably substitute the representation of a value for the value itself, yields nice benefits. In mathematics, for example in the field of Deep Learning, we are able to cheaply compute the gradient of a loss-function using the back-propagation algorithm which is simply storing intermediate values during the forward-pass so that, during the backwards-pass (or what’s known as <strong>back-propagation</strong>), we avoid redundant calculations… But this simple substitution relies on the fact that the function evaluated at input is the same as the output. By contrast, if functions in math affected external state somewhere, or produced other such side-effects (more of which we will see in the section dedicated to <a href="../../posts/functional_programming/functional_programming.html#Side-Effects"><strong>Side-effects</strong></a>), it would be a lot more difficult to come up with the optimization known as back-propagation in ML. So, when we use pure functions, we gain <em>mathematical</em> insights about our programs. In effect, we’re just modeling the solution as a chain of pure function calls and storing the results as immutable state. This also imposes a certain component of horizontal eye-movement when it comes to reading functional code.</p>
<p>In the next section we look at the differences between <strong>declarative</strong> and <strong>imperative</strong> styles of writing software and why functional programming prefers the former style.</p>
</section>
</section>
<section id="declarative-vs-imperative-styles" class="level2">
<h2 class="anchored" data-anchor-id="declarative-vs-imperative-styles">Declarative vs imperative styles</h2>
<p>At a basic level, an <em>imperative</em> style of programming can be likened to cooking at home with a cookbook. Imperative languages look more like a list of commands directed at the computer. Declarative writing, by contrast, can be compared to dining at a restaurant. We aren’t issuing commands at a grueling level of granularity (e.g.&nbsp;iterating over an array manually, or appending to a list). Instead, we’re specifying the desired outcome without the implementation details like we would in mathematics when we, for instance, write <span class="math inline">\(f(x)=x^2\)</span> succinctly (implying to square every feature of the input vector <span class="math inline">\(x\)</span>). We prefer declarative code to imperative in FP partly because imperative code involves a lot of state mutation and partly because writing pure functions facilitates writing declarative code.</p>
<p>In the imperative style, we’re saying “step through the list, read each item, square it and append it to a new list.” In the declarative style we’re saying “just square every element of this list.” These differences are mostly semantic and, in real life, software contains a mix of both styles. The distinction is also not really black or white, and is often dependent on the implementation of the given language.</p>
<p>An example is worth a thousand words and, since Python provides a good enough playground for showcasing these styles, here is an example in Python.</p>
<p><strong>Imperative Style</strong></p>
<div id="cell-2" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>squared <span class="op">=</span> []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> numbers:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    squared.append(num <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(squared)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1, 4, 9, 16, 25]</code></pre>
</div>
</div>
<p><strong>Declarative Style</strong></p>
<div id="cell-4" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>squared <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">2</span>, numbers)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(squared))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1, 4, 9, 16, 25]</code></pre>
</div>
</div>
<p>Notice how in the declarative style we merely instructed our function to square each feature, but we didn’t tell the program how to do it in grueling detail and we avoided the use of a <code>for</code> loop (which means we avoided mutating the state of the index of the loop). Also, more lines in the declarative style return a value, rather than just carrying our instructions (we will see the difference between mere instructions, or <strong>statements</strong> and pure expressions later on). However, since there’s printing to the console at the end, even the declarative program would not be considered functional.</p>
<section id="side-effects" class="level3">
<h3 class="anchored" data-anchor-id="side-effects">Side-effects</h3>
<p>Functions which violate any of the three afforementioned properties are said to produce <strong>side effects</strong> (or simply <em>effects</em>). The most common side effect is when a function modifies a state (i.e.&nbsp;a chunk of computer memory) outside itself (violating property (3)). Examples of side effects include:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>Effect</th>
<th>Functional Programming Way</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A function directly modifying a variable defined in the global scope.</td>
<td>The FP approach is to pass the global variable as input instead, and have the function return a modified copy of the input.</td>
</tr>
<tr class="even">
<td>A function writing to an external database.</td>
<td>This is an example of an <em>unavoidable side effect</em> in practice. The FP approach is to mitigate. Specifics are language dependent, but usually the strategy involves gathering all such unavoidable side effects into one impure corner of the code, and keeping the rest of the code pure.</td>
</tr>
<tr class="odd">
<td>A function like the built-in functions of printing to the console, retrieving system time, or a random number generator (or those functions which use them)</td>
<td>Yet more examples of unavoidable side effects. Such functions are inherently dependent on external or hidden state such as the time of day in the real world and, in general, things other than their input.</td>
</tr>
</tbody>
</table>
<p>Although some side effects are unavoidable, we should minimize their use in our code. Functional programming languages offer just that ability.</p>
</section>
<section id="instructions-statements-vs-expressions" class="level3">
<h3 class="anchored" data-anchor-id="instructions-statements-vs-expressions">Instructions (statements) vs expressions</h3>
<p>In functional programming, we distinguish between mere <strong>instructions</strong> to the computer (which are also sometimes known as <strong>statements</strong>) and <strong>expressions</strong> (or <strong>pure expressions</strong>). This distinction is similar to that between functions, in the programming sense, and pure functions in the mathematical sense – Expressions, like functions, must always return a value. Contrast this with instructions like the traditional <code>if</code>/<code>else</code> statements or loops like <code>while</code> which control the flow of execution, but don’t evaluate to anything.</p>
<p>As mentioned earlier, such effects are unavoidable at times. However, functional languages have different strategies of mitigating these impurities and writing pure code anyway. Usually they aim to gather the impurities together at the top or bottom of the code. Some languages (such as Scala which is a blend of OOP and FP), go to great lengths to minimize side effects by enforcing the return requirement of its syntactic structures. Even though Scala has the traditional <code>for</code> loop as an instruction, it favors the use of <code>for</code>-comprehensions which are essentially syntactic sugar (enabled by <strong>monadic</strong> types that capture effects, more on these later). Each line of a <code>for</code>-comprehension in Scala evaluates to a value.</p>
<p>The idea is to use a clever type system to capture effects. If side effects must exist, they should be known to Scala. To achieve this, Scala has a monadic type known as <code>Unit</code> which can hold only <code>()</code> as its value. This is its designated side effect type. So, functional programming languages elevate instructions or statements, which normally don’t return anything, the status of pure expressions by returning a dedicated side effect type. In practice there are many types for different side effects (for example, an <code>IO</code> monadic type captures side effects produced by operations like console logging). Let’s see some examples of how Scala does away with traditional <code>for</code> loops and <code>if</code>/<code>else</code> statements and uses pure expressions instead.</p>
</section>
<section id="control-flow-conditional-statements-and-loops" class="level3">
<h3 class="anchored" data-anchor-id="control-flow-conditional-statements-and-loops">Control flow: conditional statements and loops</h3>
<p>In Scala, <code>if</code> statements are implemented as expressions similar to the familiar <strong>ternary expressions</strong> in Python. Scala has traditional <code>if</code> statements too, but the <code>if</code> pure expression is what’s preferred. Here are some examples that demonstrate difference the difference in both Python and Scala:</p>
<p><strong>Python:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> condition <span class="op">==</span> <span class="va">True</span> <span class="cf">else</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Scala:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x <span class="op">=</span> <span class="cf">if</span> <span class="op">(</span>condition<span class="op">)</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, <code>x</code> necessarily evaluates to a value: one of possible two. This <code>if</code> expression will not produce a side effect as would an open-ended <code>if</code> statement. Inside an <code>if</code> statement, the programmer <em>might</em> just do something crazy and unheard of like accessing a database, or printing a line to the console (both considered side effects).</p>
<p>This brings us to an important point. It’s not that <code>if</code> statements would <em>necessarily</em> result in side effects, it’s just that functional programming discourages the use of language constructs that lend themselves to producing side effects more easily. Syntactic choices like this are a common theme in FP. For instance, Scala’s choice to treat <code>()</code> as a returnable value (of type <code>Unit</code>) rather than just a piece of syntax is very deliberate. Let’s see why by examining a Scala, <code>for</code>-comprehension.</p>
<p><strong>Scala For Comprehension:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> result <span class="op">=</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">&lt;-</span> <span class="fu">print</span><span class="op">(</span><span class="st">"Hello"</span><span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">&lt;-</span> <span class="fu">print</span><span class="op">(</span><span class="st">"World!"</span><span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">yield</span> <span class="op">()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It may not look like it, but the code snippet above (showing a <code>for</code>-comprehension) is one of the ways in which Scala actually chains many potentially side-effect producing operations together via function composition (which is what’s going on in the background). Notice three things about it:</p>
<ul>
<li>The <code>for</code> comprehension returns a value captured by <code>result</code>.</li>
<li>The print statement produces a side effect which is discarded as _.</li>
<li>At the end we simply say <code>yield ()</code>… If we wished to return a value instead we would do so inside the <code>()</code> however, because Scala associates a type with <code>()</code>, what’s actually returned is the side-effect captured as a <code>Unit</code> (so the for comprehension returns <em>something</em>)</li>
</ul>
</section>
<section id="function-composition-vs-iteration-and-higher-order-functions-hofs" class="level3">
<h3 class="anchored" data-anchor-id="function-composition-vs-iteration-and-higher-order-functions-hofs">Function composition vs iteration and higher-order functions (HOFs)</h3>
<p>Because FP frowns upon the use of <code>if</code>/<code>else</code> and <code>for</code>/<code>while</code> statements, it prefers function composition to iteration. In fact, the <code>for</code>-comprehension above is just cleverly disguised function composition.</p>
<p>Take, for example, a <code>while</code> loop that runs until a key press (or any other user input). Of course, this may be an unavoidable side effect in the real world. The FP approach would, then, just be to contain this impurity somewhere with the rest of its kind.</p>
<p>In general, instead of iteration, function composition is preferred (mathematical readers will understand that <em>recursion</em>, which often offers itself as an alternative to iteration when there’s <a href="https://en.wikipedia.org/wiki/Optimal_substructure">optimal substructure</a>, is a type of function composition). Functional programming prefers this approach in general. This may sound tedious and almost like re-learning how to program at first, but syntactic sugars and other abstractions exist to make this pattern more readable (like the <code>for</code>-comprehension we already saw in Scala).</p>
<p>There are already a few familiar examples of function composition that have been adopted by popular languages like Python, and are very intuitive (especially when dealing with data pipelines or modelling real world interactions in terms of sequential actions). Some examples are the <code>map</code> and the <code>filter</code> functions in Python. We already saw an example of <code>map</code> in the declarative code snippet above, so we won’t dive into its specifics here. Both <code>map</code>and <code>filter</code> are examples of <strong>higher-order functions</strong> (<strong>HoF</strong>s) – functions which take other functions as input and/or themselves output functions. <code>map</code> and <code>filter</code> show that function composition can be very readable and intuitive. Furthermore, neither <code>map</code> nor <code>filter</code> modify their input in-place. Rather, they return a modified copy of the input to avoid external state mutation which is considered poor practice in FP. Later on we shall see that a related method called <code>flatMap</code> exists which turns out to play a key role in letting functional programmers write useful programs by chaining multiple potentially side effect-producing functions together. This is due to <code>flatMap</code>’s unique function signature (which flattens arrays of arrays into one array).</p>
<section id="higher-order-functions" class="level4">
<h4 class="anchored" data-anchor-id="higher-order-functions">Higher-order functions</h4>
<p>To pipe functions into other functions (as in function composition), we need functions that take other functions as input and can also output functions. When we treat functions this way, we basically treat them as <em>first-class values</em> which means like any other value, they can be passed and returned around. There is a mathematically-inspired reason, other than designing software as function composition, for using HoFs.</p>
<p>When mathematicians write:</p>
<p><span class="math display">\[
\sum_{x=a}^{b} f(x)
\]</span></p>
<p>where, say <span class="math inline">\(a,b \in \mathcal{Z}\)</span>, they understand that <span class="math inline">\(f\)</span> stands for some general function. So there’s no need to write a separate expression for summing the integers, one for summing the <em>squares of the integers</em>, and one for summing the <em>factorials of integers</em> between <span class="math inline">\([a,b]\)</span>.</p>
<p>Let’s write a function in Scala that sums the integers:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sumInts</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&gt;</span> b then <span class="dv">0</span> <span class="cf">else</span> a <span class="op">+</span> <span class="fu">sumInts</span><span class="op">(</span>a <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To get the sum of squares, we’d need to define another function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">square</span><span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span> x <span class="op">*</span> x</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sumSquares</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&gt;</span> b then <span class="dv">0</span> <span class="cf">else</span> <span class="fu">square</span><span class="op">(</span>a<span class="op">)</span> <span class="op">+</span> <span class="fu">sumSquares</span><span class="op">(</span>a <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But there’s clearly some repetition here, so we can factor out a common pattern. What if we changed the signature of <code>sumInts</code> to take a function as argument?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sum</span><span class="op">(</span>f<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="bu">Int</span><span class="op">,</span> a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&gt;</span> b then <span class="dv">0</span> <span class="cf">else</span> <span class="fu">f</span><span class="op">(</span>a<span class="op">)</span> <span class="op">+</span> <span class="fu">sum</span><span class="op">(</span>f<span class="op">,</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can write:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sumInts</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>id<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>where <code>id</code> is the identity function:</p>
<pre><code>def id(x: Int): Int = x</code></pre>
<p>and:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sumSquares</span><span class="op">(</span>a<span class="op">:</span> <span class="dt">int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>square<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Admittedly this doesn’t look great because we’re creating a lot of boilerplate functions. To get rid of this boilerplate, Scala was the first language to introduce the notion of <em>anonymous functions</em> (in Python these are known by the <code>lambda</code> keyword). We can think of anonymous functions as literals. Similar to how we can do <code>println("hello world!")</code> without having to name the string literal <code>"hello world!"</code> using a variable, we can declare functions as literals. Using anonymous functions, the <code>id</code> and <code>square</code> functions above can be written respectively as:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=&gt;</span> x</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>x<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=&gt;</span> x <span class="op">*</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This reduces our <code>sumInts</code> and <code>sumSquares</code> to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sumInts</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span> <span class="co">// Types can be omitted if they can be inferred from context</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sumSquares</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x <span class="op">*</span> x<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Anonymous functions are syntactic sugar. That is, they aren’t necessary but make life easier.</p>
</section>
</section>
<section id="currying" class="level3">
<h3 class="anchored" data-anchor-id="currying">Currying</h3>
<p>But so far we’ve only used the HoF’s ability to accept functions as input. Let’s also use their ability to output functions. The pattern we are about to learn is called <em>currying</em> (after Haskell Curry), and it’s useful for, among other things, dependency injection.</p>
<p>Note, again, the functions:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sumInts</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sumSquares</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x <span class="op">*</span> x<span class="op">,</span> a<span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Both <code>a</code> and <code>b</code> are passed into each unchanged. Is there a common pattern we can extract? We can use currying which is just <em>partial application</em> of the function. Here’s the curried version of <code>sum</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sum</span><span class="op">(</span>f<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="bu">Int</span><span class="op">):</span> <span class="op">(</span><span class="bu">Int</span><span class="op">,</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">=&gt;</span> <span class="bu">Int</span> <span class="op">=</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">sumFn</span><span class="op">(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">&gt;</span> b then <span class="dv">0</span> <span class="cf">else</span> <span class="fu">f</span><span class="op">(</span>a<span class="op">)</span> <span class="op">+</span> <span class="fu">sumF</span><span class="op">(</span>a <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    sumF</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our <code>sum</code> functions now constructs and returns a new function which takes the rest of input the (<code>a</code> and <code>b</code>). This is called <em>partial-application</em>. We’ve split the <code>sum</code> into two parts: the first part accepts only the argument <code>f</code> as input, the second one accepts the rest of the arguments.</p>
<p>Now we can define <code>sumInts</code> and <code>sumSquares</code> respectively as just:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sumInts <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x<span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sumSquares <span class="op">=</span> <span class="fu">sum</span><span class="op">(</span>x <span class="op">=&gt;</span> x<span class="op">*</span>x<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that when we call <code>sum</code>, we get back a function with signature <code>(Int, Int) =&gt; Int</code> (which is exactly the signature we want for <code>sumInts</code> and <code>sumSquares</code>). We can now use better readable syntax like <code>sum(cube)(1,5) + sum(squares)(5,10)</code> doing away with <code>sumInts</code> and <code>sumSquares</code> (using which we’d have to write the above as: <code>sumInts(1,5) + sumSquares(5,10)</code>).</p>
<p>Since it can get quite clumsy to write curried functions, Scala provides a shorthand. This is equivalent to the curried <code>sum</code> written above.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala code-with-copy"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">sum</span><span class="op">(</span>f<span class="op">:</span> <span class="bu">Int</span> <span class="op">=&gt;</span> <span class="bu">Int</span><span class="op">)(</span>a<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> b<span class="op">:</span> <span class="bu">Int</span><span class="op">):</span> <span class="bu">Int</span> <span class="op">=</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&gt;</span> b then <span class="dv">0</span> <span class="cf">else</span> <span class="fu">f</span><span class="op">(</span>a<span class="op">)</span> <span class="fu">sum</span><span class="op">(</span>f<span class="op">)(</span>a <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> b<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In Python, there’s support for curried functions in the functools library (<a href="https://docs.python.org/3/library/functools.html#functools.partial">functools.partial</a>, which implements a curried version of a function you pass to it (by itself currying the input).</p>
<p>Currying, in general, can be applied <span class="math inline">\(n\)</span> times to an <span class="math inline">\(n\)</span>-dimensional function, each outer function returning an (anonymous) inner function which partially applies the rest of the parameters. This means languages need not have support for functions with parameters, as long as they have support for anonymous functions. In fact, the most minimal programming language, a <a href="https://learnxinyminutes.com/docs/lambda-calculus/#:~:text=Lambda%20calculus%20(%CE%BB%2Dcalculus),to%20represent%20any%20Turing%20Machine!">lambda calculus</a>, does away with parameters by relying on currying alone.</p>
</section>
<section id="monads" class="level3">
<h3 class="anchored" data-anchor-id="monads">Monads</h3>
<p><em>Monads</em> are a term borrowed from Category Theory. They have a strict definition in mathematics, but for our purposes they’re useful black boxes that provide the following benefits (some already mentioned before in passing). Monads provide a way to compose potentially side-effect producing functions together, and in general they make function composition lend itself to being abstracted behind syntactic sugars (like <a href="https://en.wikibooks.org/wiki/Haskell/Simple_input_and_output">do notation</a> in Haskell) which make functional programs more readable and more useful for in an applied sense. As a sidenote, to the readers who are familiar with JavaScript <code>Promises</code>, these are, in essence, the same as the side-effect type <code>Unit</code> in Scala (or, rather, more like the more specific <code>IO</code> side-effect). The main point is that a <code>Promise</code> <em>also</em> a monad, which makes it possible to come up with nice, syntactic sugars like <code>async</code> <code>await</code>. In fact, do notation in Haskell is actually the generalized version of this type of <code>async</code> <code>await</code> pattern that works with <em>any monad</em> and not just a <code>Promise</code>.</p>
<p>Monads, as far as we’re concerned, are abstract classes that implement <code>flatMap</code> (also <code>map</code>, also an <em>identity map</em>, but the big picture is lost in the details). Yes, this is the same <code>flatMap</code> we discussed earlier in the context of it being one of the higher-order functions that are popularly used in more mainstream languages like Python. It turns out, chaining two side-effect producing operations by function compositi produces nested side-effects (and if we’re using a language that uses <em>types</em> to capture side-effects, then we quickly generate some nasty, nested types). For example, chaining two IO operations that prompt the user for two strings may produce something like <code>IO(IO(String))</code>. So what’s <code>flatMap</code>’s role in all of this? Our friend, <code>flatMap</code>, with its unique capacity to flatten, is <em>exactly</em> the thing that’s needed to get an <code>IO(String)</code>) back! We will discuss this flattening property of <code>flatMap</code> in more detail later on. For now, it’s important to re-iterate that having an implementation of <code>flatMap</code>, which may go by other names in other languages (e.g.&nbsp;<code>Bind</code> in Haskell), is, along with a few other key properties, what qualifies an abstract class to be a monad.</p>
<p>For more on Monads, and <code>flatMap</code>, check out this excellently visualized <a href="https://www.cocoawithlove.com/blog/an-aside-about-flatmap-and-monads.html">blog post by Matt Gllagher</a>.</p>
<p>So, it’s no wonder that in a functional programming language we want our side effect-producing expressions to return a monadic type, so that we can chain two or more of such expressions together (using function composition) without generating a nested mess.</p>
</section>
</section>
<section id="benefits-of-functional-programming" class="level2">
<h2 class="anchored" data-anchor-id="benefits-of-functional-programming">Benefits of functional programming</h2>
<section id="parallelization" class="level3">
<h3 class="anchored" data-anchor-id="parallelization">Parallelization</h3>
<p>FP confers some benefit in terms of parallelization because:</p>
<ul>
<li>A common challenge in parallel programming is to avoid mutating data while another <strong>thread</strong> is using it. Due to state immutability principles in FP, this problem is eliminated</li>
<li>FP avoids writing functions which rely on hidden state (i.e.&nbsp;any state that’s not a direct input), so functions can be executed in parallel without the concern of synchronizing access to some shared state.</li>
<li>FP can make it easier to identify opportunities for parallelization</li>
<li>Languages which are built around FP have powerful parallelization libraries that offer parallelized versions of common operations like <code>map</code></li>
</ul>
</section>
</section>
<section id="functional-programming-hazards" class="level2">
<h2 class="anchored" data-anchor-id="functional-programming-hazards">Functional programming hazards</h2>
<section id="tail-recursion-avoiding-stack-overflow" class="level3">
<h3 class="anchored" data-anchor-id="tail-recursion-avoiding-stack-overflow">Tail recursion: avoiding stack overflow</h3>
<p>If we’re going to favor the use of recursion (or, in general function composition) over the more imperative style of coding, we ought to tread carefully as to not cause <strong>stack overflow</strong> (which, as we know, is when the system runs out of working memory). <strong>Tail recursion optimization</strong> (similar to other techniques like <strong>memoization</strong>) helps us drastically cut the amount of stack memory used. It takes a constant amount of memory on the stack, instead of linear or worse. Read more about tail recursive optimization <a href="../../unpublished_posts/general_computer_science/recursion_optimizations.html">here</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/v-poghosyan\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="v-poghosyan/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2021, Vahram Poghosyan</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.github.com/v-poghosyan">
      <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/vahrampoghosyan/">
      <i class="bi bi-linkedin" role="img" aria-label="GitHub">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script type="application/javascript" src="../../javascript/light-dark.js"></script>




</body></html>