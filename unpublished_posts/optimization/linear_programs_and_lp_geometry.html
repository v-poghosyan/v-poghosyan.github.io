<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vahram Poghosyan">
<meta name="dcterms.date" content="2022-01-23">

<title>Notes: Linear Programs and LP Geometry – v-poghosyan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-KLCX05QFPN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-KLCX05QFPN', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../assets/site/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">v-poghosyan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Info</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Notes: Linear Programs and LP Geometry</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Optimization</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Vahram Poghosyan </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 23, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications">Applications</a></li>
  </ul></li>
  <li><a href="#feasibility-and-boundedness" id="toc-feasibility-and-boundedness" class="nav-link" data-scroll-target="#feasibility-and-boundedness">Feasibility and Boundedness</a></li>
  <li><a href="#converting-to-standard-form" id="toc-converting-to-standard-form" class="nav-link" data-scroll-target="#converting-to-standard-form">Converting to Standard Form</a>
  <ul class="collapse">
  <li><a href="#introducing-slack-variables" id="toc-introducing-slack-variables" class="nav-link" data-scroll-target="#introducing-slack-variables">Introducing Slack Variables</a></li>
  </ul></li>
  <li><a href="#geometry-of-linear-programs" id="toc-geometry-of-linear-programs" class="nav-link" data-scroll-target="#geometry-of-linear-programs">Geometry of Linear Programs</a>
  <ul class="collapse">
  <li><a href="#extreme-points---geometric-definitions" id="toc-extreme-points---geometric-definitions" class="nav-link" data-scroll-target="#extreme-points---geometric-definitions">Extreme Points - Geometric Definitions</a></li>
  <li><a href="#extreme-points---algebraic-definition" id="toc-extreme-points---algebraic-definition" class="nav-link" data-scroll-target="#extreme-points---algebraic-definition">Extreme Points - Algebraic Definition</a>
  <ul class="collapse">
  <li><a href="#basic-feasible-solution" id="toc-basic-feasible-solution" class="nav-link" data-scroll-target="#basic-feasible-solution">Basic Feasible Solution</a></li>
  <li><a href="#matrix-vector-formulation-of-basic-feasible-solutions" id="toc-matrix-vector-formulation-of-basic-feasible-solutions" class="nav-link" data-scroll-target="#matrix-vector-formulation-of-basic-feasible-solutions">Matrix-Vector Formulation of Basic Feasible Solutions</a></li>
  <li><a href="#basic-feasible-solutions-and-extreme-points-are-equivalent" id="toc-basic-feasible-solutions-and-extreme-points-are-equivalent" class="nav-link" data-scroll-target="#basic-feasible-solutions-and-extreme-points-are-equivalent">Basic Feasible Solutions and Extreme Points are Equivalent</a></li>
  </ul></li>
  <li><a href="#the-extreme-point-theorem" id="toc-the-extreme-point-theorem" class="nav-link" data-scroll-target="#the-extreme-point-theorem">The Extreme Point Theorem</a>
  <ul class="collapse">
  <li><a href="#proof-1" id="toc-proof-1" class="nav-link" data-scroll-target="#proof-1">Proof</a></li>
  <li><a href="#sketch-for-an-alternate-proof" id="toc-sketch-for-an-alternate-proof" class="nav-link" data-scroll-target="#sketch-for-an-alternate-proof">Sketch for an Alternate Proof</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>A linear program is a special type of convex optimization problem in <span class="math inline">\(n\)</span>-dimensions that has a linear objective and a constraint set that’s a polytope. That is, its constraint set is an intersection of <span class="math inline">\(n\)</span>-dimensional linear inequalities (<em>halfspaces</em>) and linear equalities (<em>hyperplanes</em>).</p>
<p>In matrix form, it may be stated as</p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx
\\
s.t.: \begin{aligned} &amp;A_1x \leq b_1
\\
&amp;A_2x \geq b_2
\\
&amp;A_3x = b_3
\end{aligned}
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(c \in \mathbb{R}^n\)</span> is the <em>cost vector</em> of the objective function, <span class="math inline">\(x \in \mathbb{R^n}\)</span> is the <em>decision variable</em>, <span class="math inline">\(A_1 \in \mathbb{R}^{m \times n}\)</span>, <span class="math inline">\(b_1 \in \mathbb{R}^m\)</span> and <span class="math inline">\(A_2 \in \mathbb{R}^{p \times n}\)</span>, <span class="math inline">\(b_2 \in \mathbb{R}^p\)</span> together define the collection of linear inequality constraints, and <span class="math inline">\(A_3 \in \mathbb{R}^{q \times n}\)</span> and <span class="math inline">\(b_3 \in \mathbb{R}^q\)</span> define the collection of linear equality constraints.</p>
<p>As we will shortly prove, an LP in any form such as the one above can be converted into its <em>standard form</em></p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx
\\
s.t.: \begin{aligned} &amp;Ax = b
\\
&amp;x \geq 0
\end{aligned}
\end{cases} \dagger
\]</span></p>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<p>Linear programs are only a small subset of convex optimization problems (in fact, a strict subset of semidefinite programs) but they’re robust enough to model many real-life scenarios. For instance, even though they are continuous optimization problems, due to their geometry — namely the fact that optimal solutions to an LP may occur only at the extreme points of the constraint set — they have a strong combinatorial flavor. This is why LP’s are highly successful at modeling problems that are inherently combinatorial — problems of scheduling, finding the shortest path, modeling a <a href="../optimization/modeling_discrete_failures.ipynb">discrete failures scenario</a>, etc.</p>
<p>The reason LP’s are of special interest in the study of optimization is due to the availability of fast algorithms that solve them. So, if a convex optimization problem happens to also be an LP, we can solve it much faster.</p>
</section>
</section>
<section id="feasibility-and-boundedness" class="level1">
<h1>Feasibility and Boundedness</h1>
<p>There are two ways in which LP’s may fail to have an optimal solution, by either being <em>infeasible</em> or <em>unbounded</em>. Both of these cases are typically uninteresting in practice however they give important theoretical results. It’s also useful to check whether or not a given LP is feasible and bounded before attempting to optimize.</p>
<p>Infeasible LP’s are those LP’s that have an empty constraint set, whereas unbounded LP’s have open constraint sets. However, it’s important to understand that an LP may have an open constraint set without being unbounded.</p>
<p>Consider the two examples below</p>
<p><span class="math display">\[
\begin{cases}
\min_{x_1}: x_1
\\
s.t.: x_1 \leq 4
\end{cases} \tag{1}
\]</span></p>
<p><span class="math display">\[
\begin{cases}
\min_{x_1}: x_1
\\
s.t.: x_1 \geq 4
\end{cases} \tag{2}
\]</span></p>
<p>The first problem is unbounded, since <span class="math inline">\(x_1\)</span> can be taken arbitrarily small. However, the second problem is bounded despite having an open constraint set. The optimal value of <span class="math inline">\((2)\)</span> is <span class="math inline">\(x_1 = 4\)</span>.</p>
<p>Thus, an LP is said to be unbounded not when its constraint polytope is open, but when it’s feasible and has no optimal solution.</p>
</section>
<section id="converting-to-standard-form" class="level1">
<h1>Converting to Standard Form</h1>
<p>Given any starting point, an LP can be written in standard form <span class="math inline">\(\dagger\)</span>. This is useful for standardization of the problem from an algorithmic perspective, and it’s what the <a href="https://en.wikipedia.org/wiki/Simplex_algorithm">Simplex algorithm</a> relies on to solve LP’s.</p>
<p>In the most general case an LP can be stated with inequality constraints going in both directions and equality constraints as follows</p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx
\\
s.t.: \begin{aligned} &amp;A_1x \leq  b_1
\\
&amp;A_2x \geq  b_2
\\
&amp;A_3x = b_3
\end{aligned}
\end{cases}
\]</span></p>
<p>But the inequality constraints can always be combined into <span class="math inline">\(Ax \leq b\)</span> for <span class="math inline">\(A = [A_1, A_2]\)</span> and <span class="math inline">\(b = [b_1, -b_2]^T\)</span> and relabeled as <span class="math inline">\(A_1\)</span> and <span class="math inline">\(b_1\)</span>.</p>
<p>So there’s no qualitative difference between having two types of inequalities versus just one. Simply concatenate and relabel the matrices to get</p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx
\\
s.t.: \begin{aligned} &amp;A_1x \leq  b_1
\\
&amp;A_2x = b_2
\end{aligned}
\end{cases}
\]</span></p>
<p>The real challenge lies in converting the inequality constraints <span class="math inline">\(A_1x \leq b_1\)</span> into equality constraints <span class="math inline">\(A_1x = b_1\)</span>.</p>
<section id="introducing-slack-variables" class="level2">
<h2 class="anchored" data-anchor-id="introducing-slack-variables">Introducing Slack Variables</h2>
<p>The inequality constraint <span class="math inline">\(A_1x \leq b_1\)</span> has <em>slack</em>. Formally, we can define vector <span class="math inline">\(s \geq 0\)</span> (component-wise), that bridges the gap between <span class="math inline">\(A_1x\)</span> and <span class="math inline">\(b_1\)</span>, that is s.t. <span class="math inline">\(A_1x + s = b_1\)</span>.</p>
<p>Since this introduces new variables, we have to represent those in the objective and the equality constraints in a way that doesn’t affect the optimization outcome.</p>
<p>The LP becomes</p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx + \mathbf{0}^Ts
\\
s.t.: \begin{aligned} &amp;A_1x + s = b_1
\\
&amp;A_2x + 0s = b_2
\\
&amp;s \geq 0
\end{aligned}
\end{cases}
\]</span></p>
<p>This LP is equivalent to the one before. Namely, if the previous optimizer was <span class="math inline">\(x^*\)</span>, the optimizer in the new LP is the concatenation <span class="math inline">\([x^*, b_1 - A_1x]\)</span> which gives the same optimal value in the objective function.</p>
<p>This is almost in standard form, an LP with only equality constraints, and non-negativity constraints. However, the decision variable of this LP is the concatenation <span class="math inline">\([x,s]^T\)</span>, whereas the non-negativity applies to <span class="math inline">\(s\)</span> alone.</p>
<p>The next step is to decompose <span class="math inline">\(x\)</span> as <span class="math inline">\(x = x^+ - x^-\)</span> where <span class="math inline">\(x^+,x^- \geq 0\)</span> respectively contain only the positive and only the negative entries of <span class="math inline">\(x\)</span>. That is, <span class="math inline">\(x^+\)</span>, and <span class="math inline">\(x^-\)</span> have entries <span class="math inline">\(x_i^+ = \max\{0, x_i\}\)</span> and <span class="math inline">\(x_i^- = -\min\{0, x_i\}\)</span>.</p>
<p>With this substitution we get</p>
<p><span class="math display">\[
\begin{cases}
\min_x: c^Tx^+ - c^Tx^- + \mathbf{0}^Ts
\\
s.t.: \begin{aligned} &amp;A_1x^+ - A_1x^- + s = b_1
\\
&amp;A_2x^+ - A_2x^- + 0s = b_2
\\
&amp;x^+, x^-, s \geq 0
\end{aligned}
\end{cases}
\]</span></p>
<p>Which is an LP in standard form <span class="math inline">\(\dagger\)</span>.</p>
</section>
</section>
<section id="geometry-of-linear-programs" class="level1">
<h1>Geometry of Linear Programs</h1>
<p>Take a simple feasible, bounded LP in two dimensions that has a unique solution, draw its polygonal constraint set. Then draw the level sets of the objective function noting that the direction of steepest change (the positive or negative gradient) is perpendicular to the level sets. The conclusion is almost immediate — the unique optimal solution occurs at a vertex (i.e.&nbsp;an <em>extreme point</em>) of the polygonal constraint set.</p>
<p>To formalize this, we need to introduce a few definitions and prove a theorem called The Extreme Point Theorem which can be found towards the end of this post.</p>
<section id="extreme-points---geometric-definitions" class="level2">
<h2 class="anchored" data-anchor-id="extreme-points---geometric-definitions">Extreme Points - Geometric Definitions</h2>
<p>First, let’s give a couple of geometric definitions of an extreme point.</p>
<blockquote class="blockquote">
<p><strong>Definition 1:</strong> &nbsp; A point <span class="math inline">\(x\)</span> is an <strong>extreme point</strong> of a polytope <span class="math inline">\(P\)</span> if it is <em>not</em> the convex combination of any other two points in the polytope.</p>
</blockquote>
<p>That is, if <span class="math inline">\(\exists y,z \in P\)</span> and <span class="math inline">\(\lambda \in [0,1]\)</span> s.t. <span class="math inline">\(x = \lambda y + (1- \lambda)z\)</span> then <span class="math inline">\(x\)</span> is <em>not</em> an extreme point of <span class="math inline">\(P\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition 2:</strong> &nbsp; A point <span class="math inline">\(x\)</span> is an <strong>extreme point</strong> of a polytope <span class="math inline">\(P\)</span> if it is the <em>unique</em> optimum for some cost vector <span class="math inline">\(c\)</span>.</p>
</blockquote>
<p>That is, if <span class="math inline">\(\exists c \in \mathbb{R}^n\)</span> s.t. <span class="math inline">\(c^Tx &lt; c^Ty \ \ \forall y \in P\)</span> then <span class="math inline">\(x\)</span> is an extreme point.</p>
</section>
<section id="extreme-points---algebraic-definition" class="level2">
<h2 class="anchored" data-anchor-id="extreme-points---algebraic-definition">Extreme Points - Algebraic Definition</h2>
<p>It’s useful to define an extreme point algebraically. To that end, let’s define the concept of a <em>basic feasible solution (BFS)</em>.</p>
<p>Suppose we have the polytope <span class="math inline">\(\{x : Ax \leq b, Dx = f\}\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> &nbsp; An <strong>active constraint at <span class="math inline">\(x\)</span></strong> is a constraint that’s satisfied through strict equality.</p>
</blockquote>
<p>That is, the <span class="math inline">\(i\)</span>-th constraint is said to be active at x if <span class="math inline">\(a_i^Tx = b_i\)</span>.</p>
<p>This can be thought of as <span class="math inline">\(x\)</span> being on the edge of the halfspace defined by <span class="math inline">\(a_i^Tx \leq b_i\)</span>.</p>
<p>We can also define the <em>active set</em> at <span class="math inline">\(x\)</span> as the set of all active constraints at <span class="math inline">\(x\)</span>.</p>
<p>So, the active set at <span class="math inline">\(x\)</span> is <span class="math inline">\(\mathcal{A}_x = \{ a_i : a_i^Tx = b_i \} \cup \{ d_i : d_i^Tx = f_i \}\)</span>, where <span class="math inline">\(\{ d_i : d_i^Tx = f_i \}\)</span> is included for completeness.</p>
<section id="basic-feasible-solution" class="level3">
<h3 class="anchored" data-anchor-id="basic-feasible-solution">Basic Feasible Solution</h3>
<p>We are now ready to define what it means for a point <span class="math inline">\(x\)</span> to be a basic feasible solution of a linear program.</p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> &nbsp; The point <span class="math inline">\(x\)</span> is a <strong>basic feasible solution (BFS)</strong> of the linear program if its active set <span class="math inline">\(\mathcal{A}_x\)</span> contains exactly <span class="math inline">\(n\)</span> linearly independent vectors where <span class="math inline">\(n\)</span> is the dimension of <span class="math inline">\(x\)</span>.</p>
</blockquote>
<p>Let’s ponder the BFS definition for a minute.</p>
<p>Imagine a closed polytope in 2D. Each of its vertices are defined by, at least, two intersecting lines. It’s possible that a vertex is the result of the intersection of three or more lines, but deleting all but two of those lines will still retain the vertex. In other words, two linearly independent (i.e.&nbsp;non-parallel) constraints define an extreme point in 2D.</p>
<p>The BFS definition is simply a generalization of this insight to <span class="math inline">\(n\)</span>-dimensions.</p>
<p>As we will prove shortly, BFS and extreme point are synonymous. In fact, the following are equivalent:</p>
<ul>
<li><span class="math inline">\(x\)</span> is an extreme point by <em>Definition 1</em>.</li>
<li><span class="math inline">\(x\)</span> is an extreme point by <em>Definition 2</em>.</li>
<li><span class="math inline">\(x\)</span> is a basic feasible solution.</li>
</ul>
</section>
<section id="matrix-vector-formulation-of-basic-feasible-solutions" class="level3">
<h3 class="anchored" data-anchor-id="matrix-vector-formulation-of-basic-feasible-solutions">Matrix-Vector Formulation of Basic Feasible Solutions</h3>
<p>Taking as our starting point an LP in standard form <span class="math inline">\(\dagger\)</span> we can characterize basic feasible solutions in matrix-vector form.</p>
<p>Take the standard constraint set <span class="math inline">\(\Omega = \{ Ax = b, x \geq 0 \}\)</span> and let’s make a few simplifying assumptions.</p>
<ol type="1">
<li><span class="math inline">\(A\)</span> is <span class="math inline">\(m \times n\)</span> with <span class="math inline">\(m \leq n\)</span>.</li>
<li><span class="math inline">\(A\)</span> is full-rank</li>
<li><span class="math inline">\(b \geq 0\)</span></li>
<li><span class="math inline">\(A\)</span> has form <span class="math inline">\(A = [B,D]\)</span> where <span class="math inline">\(B\)</span> is an <span class="math inline">\(m \times m\)</span> full-rank matrix and <span class="math inline">\(D\)</span> is the rest of <span class="math inline">\(A\)</span>.</li>
</ol>
<p>Some of these assumptions impose restrictions on <span class="math inline">\(\Omega\)</span>, whereas others are without loss of generality.</p>
<p>Assumption 1 is simply there to make the problem interesting. Were <span class="math inline">\(n &gt; m\)</span>, the system of equalities would be over-determined and the constraint set would either be empty or contain a single point, which itself would be the optimum. It is, therefore an assumption which is <em>not</em> done without loss of generality.</p>
<p>Assumption 2 is equivalent to saying <span class="math inline">\(rank(A) = m\)</span>. That is to say, all <span class="math inline">\(m\)</span> rows of <span class="math inline">\(A\)</span>, as well as <span class="math inline">\(m\)</span> of the <span class="math inline">\(n\)</span> columns of <span class="math inline">\(A\)</span>, are linearly independent. This assumption is also <em>not</em> done without loss of generality. Having less linearly independent rows corresponds to having less non-redundant constraints which clearly affects the constraint set <span class="math inline">\(\Omega\)</span>.</p>
<p>Assumption 3 is done W.L.O.G. since the signs of <span class="math inline">\(A\)</span>’s row entries can always be flipped.</p>
<p>Assumption 4 is also done W.L.O.G. because if <span class="math inline">\(A\)</span> contains a full-rank <span class="math inline">\(m \times m\)</span> submatrix per Assumption 2, then <span class="math inline">\(A = [B,D]\)</span> is a re-ordering of <span class="math inline">\(A\)</span> which adds no further restrictions on <span class="math inline">\(\Omega\)</span>.</p>
<p>For <span class="math inline">\(\Omega\)</span> that satisfies Assumptions 1-4, the basic feasible solutions can be reformulated as follows.</p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> &nbsp; Let <span class="math inline">\(x_B\)</span> be such that. <span class="math inline">\(Bx_B = b\)</span>. Then the concatenation <span class="math inline">\(x = [x_B, 0]^T\)</span> is a solution to <span class="math inline">\(Ax = b\)</span>. Such solutions are called <strong>feasible solutions</strong>. Furthermore, if <span class="math inline">\(x_B \geq 0\)</span>, such solutions are called <strong>basic feasible solutions</strong>.</p>
</blockquote>
<p>Note that, for the case we’re in, this is consistent with the earlier definition of a BFS.</p>
<p>Let <span class="math inline">\(x\)</span> be a BFS according to this definition. <span class="math inline">\(Ax = b\)</span> poses a set of <span class="math inline">\(m\)</span> linearly independent constraints since <span class="math inline">\(rank(A) = m\)</span>, whereas <span class="math inline">\(x \geq 0\)</span> poses a set of <span class="math inline">\(n\)</span>. But <span class="math inline">\(x = [x_B, 0]^T\)</span> is a vector at which all <span class="math inline">\(m\)</span> of the equality constraints <span class="math inline">\(Ax = b\)</span> are active, and <span class="math inline">\(n-m\)</span> of the inequality constraints <span class="math inline">\(x \geq 0\)</span> are also active. So in total <span class="math inline">\(n\)</span> linearly independent constraints are active at a BFS, which is consistent with the earlier definition.</p>
</section>
<section id="basic-feasible-solutions-and-extreme-points-are-equivalent" class="level3">
<h3 class="anchored" data-anchor-id="basic-feasible-solutions-and-extreme-points-are-equivalent">Basic Feasible Solutions and Extreme Points are Equivalent</h3>
<p>To formally prove that basic feasible solutions are extreme points in the geometric sense, consider the following theorem and its proof.</p>
<blockquote class="blockquote">
<p><strong>Theorem:</strong> &nbsp; The point <span class="math inline">\(x\)</span> is an extreme point of <span class="math inline">\(\Omega = \{ Ax =b, x \geq 0 \}\)</span> if and only if it is a basic feasible solution.</p>
</blockquote>
<section id="proof" class="level4">
<h4 class="anchored" data-anchor-id="proof">Proof</h4>
<p><strong>Sufficiency <span class="math inline">\(\implies\)</span>:</strong></p>
<p>Let <span class="math inline">\(x\)</span> be an extreme point of <span class="math inline">\(\Omega\)</span>. Since it’s in <span class="math inline">\(\Omega\)</span>, <span class="math inline">\(x \geq 0\)</span> and <span class="math inline">\(Ax = b\)</span>.</p>
<p>Equivalently, <span class="math inline">\(\sum_{i=1}^n x_ia_i = b\)</span> where the <span class="math inline">\(a_i\)</span>’s are the column vectors of <span class="math inline">\(A\)</span>.</p>
<p>Note that <span class="math inline">\(x\)</span> <em>must</em> contain zero entries, since it takes <span class="math inline">\(n\)</span> linearly independent active constraints to be an extreme point and only <span class="math inline">\(m\)</span> come from the equality constraints <span class="math inline">\(Ax = b\)</span>.</p>
<p>By Assumption 1, <span class="math inline">\(m\)</span> of <span class="math inline">\(A\)</span>’s columns are linearly independent. We’d like to claim that these <span class="math inline">\(m\)</span> are exactly those corresponding to the non-zero <span class="math inline">\(x_i\)</span> entries.</p>
<p>If this claim turns out to be true, then the full-rank <span class="math inline">\(m \times m\)</span> submatrix <span class="math inline">\(B\)</span> will contain exactly those <span class="math inline">\(m\)</span> columns. And <span class="math inline">\(x = [x_B, 0]^T\)</span>, where <span class="math inline">\(x_B\)</span> are the non-zero entries of <span class="math inline">\(x\)</span>, would be a BFS. <span class="math inline">\(\ast\)</span></p>
<p>So, let’s prove the linear independence claim using a contradiction argument.</p>
<p>Without loss of generality, through rearrangement, let the first <span class="math inline">\(m\)</span> elements be the nonzero entries. That is, <span class="math inline">\(x_1, ..., x_m &gt; 0\)</span>, and <span class="math inline">\(x_{m+1}, ... ,x_n = 0\)</span>.</p>
<p>Then <span class="math inline">\(\sum_{i=1}^n x_ia_i = \sum_{i=1}^m x_ia_i = b\)</span>.</p>
<p>Towards contradiction, assume <span class="math inline">\(a_1, ..., a_m\)</span> are linearly dependent. Then <span class="math inline">\(\exists y_1, ..., y_m \in \mathbb{R}\)</span> not all zero s.t. <span class="math inline">\(y_1a_1 + ... + y_ma_m = 0\)</span></p>
<p>Take <span class="math inline">\(\epsilon &gt; 0\)</span> to be very small. Small enough so that <span class="math inline">\(x_i \pm \epsilon y_i &gt; 0 \ \ \forall i = 1,...,m\)</span>.</p>
<p>Define two points as</p>
<p><span class="math inline">\(z^1 = [x_1 - \epsilon y_1, ..., x_p - \epsilon y_p, 0, ..., 0]^T\)</span> and, <span class="math inline">\(z^2 = [x_1 + \epsilon y_1, ..., x_p + \epsilon y_p, 0, ..., 0]^T\)</span>.</p>
<p>These points clearly satisfy <span class="math inline">\(z_1,z_2 \geq 0\)</span>, so they they satisfy one of <span class="math inline">\(\Omega\)</span>’s constraints.</p>
<p>Furthermore,</p>
<p><span class="math inline">\(Az^1 = \sum_{i=1}^m z^1_ia_i = \sum_{i=1}^m x_ia_i - \epsilon \sum_{i=1}^m y_ia_i = b\)</span> since <span class="math inline">\(\sum_{i=1}^m y_ia_i = 0\)</span>.</p>
<p>and similarly <span class="math inline">\(Az^2 = b\)</span>.</p>
<p>So, <span class="math inline">\(z^1\)</span>, and <span class="math inline">\(z^2\)</span> are indeed in <span class="math inline">\(\Omega\)</span>.</p>
<p>But note that <span class="math inline">\(x = \frac{z^1 + z^2}{2}\)</span> is a convex combination of two points in <span class="math inline">\(\Omega\)</span>, which contradicts the assumption that it’s an extreme point.</p>
<p>Hence, <span class="math inline">\(a_1,...,a_m\)</span> must be linearly independent. This concludes the proof by <span class="math inline">\(\ast\)</span>.</p>
<p><strong>Necessity <span class="math inline">\(\impliedby\)</span>:</strong></p>
<p>Suppose <span class="math inline">\(x\)</span> is a BFS and assume, towards contradiction, that it’s <em>not</em> and extreme point of <span class="math inline">\(\Omega\)</span>.</p>
<p>Then <span class="math inline">\(\exists y,z \in \Omega\)</span> with <span class="math inline">\(y \ne z\)</span> s.t. <span class="math inline">\(x = \alpha y + (1- \alpha) z\)</span> for some <span class="math inline">\(\alpha \in (0,1)\)</span>.</p>
<p>But since <span class="math inline">\(y,z \in \Omega\)</span> they satisfy <span class="math inline">\(Ay = Az = b\)</span>, so <span class="math inline">\(Ay - Az = A(y - z) = 0\)</span>.</p>
<p>That is <span class="math inline">\((y_1 - z_1)a_1 + ... + (y_m - z_m)a_m = 0\)</span>.</p>
<p>But since <span class="math inline">\(y \ne z\)</span>, not all <span class="math inline">\((y_i - z_i) = 0\)</span>. So, <span class="math inline">\(a_1,..., a_m\)</span> are linearly dependent. This contradicts the assumption that <span class="math inline">\(x\)</span> was a BFS.</p>
</section>
</section>
</section>
<section id="the-extreme-point-theorem" class="level2">
<h2 class="anchored" data-anchor-id="the-extreme-point-theorem">The Extreme Point Theorem</h2>
<p>Why devote so much time defining extreme points geometrically, and then again algebraically? As hinted earlier and as shall be proved shortly, optima of linear programs occur at the extreme points. This is the reason LP’s are a class of easy convex optimization problems — the search space for their optima can be reduced to a finite number of extreme points.</p>
<blockquote class="blockquote">
<p><strong>The Extreme Point Theorem:</strong> &nbsp; If a linear program has a finite optimum, and its constraint polytope has at least one extreme point, then there is an extreme point which is optimal.</p>
</blockquote>
<p>So, if we want to solve linear programs we need only consider the extreme points.</p>
<p>Let’s prove the theorem through induction on the dimension.</p>
<section id="proof-1" class="level3">
<h3 class="anchored" data-anchor-id="proof-1">Proof</h3>
<p>Take the following general LP and assume it has a finite optimum. Assume also that its constraint polytope has, at least, one extreme point.</p>
<p><span class="math display">\[
\begin{cases}
\min_{x}: c^Tx
\\
s.t.: x \in \mathcal{P}
\end{cases}
\]</span></p>
<p>Assume the theorem is true for this LP with an <span class="math inline">\((n-1)\)</span>-dimensional constraint polytope. The objective is to show that it’s also true for the same LP with an <span class="math inline">\(n\)</span>-dimensional constraint polytope.</p>
<p>Let <span class="math inline">\(v\)</span> be the optimal value of the LP.</p>
<p>Let <span class="math inline">\(Q = P \cap \{ x : c^Tx = v \}\)</span> be the intersection of the constraint polytope with the level set of the objective function at the optimal value.</p>
<p>Since <span class="math inline">\(Q\)</span> is the intersection of an <span class="math inline">\(n\)</span>-dimensional polytope <span class="math inline">\(P\)</span> with an additional linear constraint (a hyperplane), it is <span class="math inline">\((n-1)\)</span>-dimensional.</p>
<p>By the inductive hypothesis, there is an extreme point <span class="math inline">\(x^* \in Q\)</span> that’s optimal for the LP.</p>
<p>By a contradiction argument, <span class="math inline">\(x^*\)</span> is also an extreme point in <span class="math inline">\(P\)</span>.</p>
<p>Suppose it is <em>not</em> an extreme point in <span class="math inline">\(P\)</span>. Then by <em>Definition 1</em> of extreme point, <span class="math inline">\(x^*\)</span> is a convex combination of two points in <span class="math inline">\(P\)</span>. That is, <span class="math inline">\(\exists y,z \in P\)</span> s.t. <span class="math inline">\(\lambda y + (1- \lambda)z = x^*\)</span> for some <span class="math inline">\(\lambda \in [0,1].\)</span></p>
<p>But then <span class="math inline">\(\lambda c^Ty + (1- \lambda)c^Tz = c^Tx^* = v\)</span>, since <span class="math inline">\(x^*\)</span> is optimal. But the left hand side is a convex combination of scalars, so <span class="math inline">\(c^Ty = c^Tz = v\)</span>. This means <span class="math inline">\(y,z \in Q\)</span>, which contradicts the fact that <span class="math inline">\(x^*\)</span> is an extreme point in <span class="math inline">\(Q\)</span>.</p>
<p>Hence, <span class="math inline">\(x^*\)</span> must be an extreme point in <span class="math inline">\(P\)</span>.</p>
</section>
<section id="sketch-for-an-alternate-proof" class="level3">
<h3 class="anchored" data-anchor-id="sketch-for-an-alternate-proof">Sketch for an Alternate Proof</h3>
<p>We can also prove the Extreme Point Theorem using a recursive argument. Recall that a continuous <span class="math inline">\(1\)</span>-dimensional function <span class="math inline">\(f: \mathcal{D} \rightarrow \mathbb{R}\)</span> on a closed interval <span class="math inline">\(\mathcal{D} \subset \mathbb{R}\)</span> necessarily achieves a min/max either on the endpoints of <span class="math inline">\(\mathcal{D}\)</span> or somewhere inside. If we additionally stipulate that <span class="math inline">\(f\)</span> is linear, the only possibilities are the endpoints. Extending this logic to linear programs in <span class="math inline">\(n\)</span>-dimensions which have finite optimal solutions, we conclude that the optimal solution cannot occur at any interior point of the constraint polytope <span class="math inline">\(\mathcal{P}\)</span> and, instead, must occur somewhere on its boundary. But now we can consider the <span class="math inline">\((n-1)\)</span>-dimensional polytopes forming <span class="math inline">\(\mathcal{P}\)</span>’s boundary separately and apply the same logic to each one recursively. In the base case, we reach the conclusion that the optimal solution must occur at an endpoint of a <span class="math inline">\(1\)</span>-dimensional polytope — a line segment such as <span class="math inline">\(\mathcal{D}\)</span>. Such a point is an extreme point of the constraint polytope.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Linear programs are a sub-class of convex optimization problems for which the search space can be reduced to a finite set of basic feasible solutions or extreme points. Furthermore, all LP’s can be written in a standard form which lends itself to being solved using a number of fast, iterative algorithms. So, although writing an optimization problem in LP form can be a difficult task, the payoff is worth it.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/v-poghosyan\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2021, Vahram Poghosyan</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.github.com/v-poghosyan">
      <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/vahrampoghosyan/">
      <i class="bi bi-linkedin" role="img" aria-label="GitHub">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script type="application/javascript" src="../../javascript/light-dark.js"></script>




</body></html>